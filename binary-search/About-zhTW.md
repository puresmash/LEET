## 概念
### 基礎
Binary Search 有效的秘訣是它每次都成功的排除了一半的可能性，無需遍歷所有元素，讓它能夠有 O(logn) 而不是 O(n) 的效率。
- 返回時，代表了已經在解答空間裡找到了答案
- 當它不返回而停止時，代表了已經沒有需要排除的解答空間 (solution space is empty)，所以沒必要繼續了。

### 衍伸
承基礎討論，存在兩種運用 Binary Search 的方式
1. 找到答案，最基礎的應用

    ```js
    while(l < r) {
      // ...
      if (m = target) return;
      if (m > target) // ...
      else // ...
    }

    ```

2. 利用它縮小解答空間，通常用於*不知道答案本身*，所以排除一定不是答案的一半

    ```js
    while (l < r) {
      // ...
      if (m > target) //...
      else //...
    }
    ```
    可參考 LC 744，在此要找大於 target 的最小值。

    舉例來說假設解答空間為 [1, 3, 5, 7, 9]，中間數為 num[2] = 5。以下解釋想法。

    - target 為 4 => [5, 7, 9] 都大於 target，則 [7, 9] 一定不會是最小值，而 5 是否會是答案中的最小值目前還不知道，所以保留 [1, 3, 5] 在第二動檢驗。
    - target 為 6 => m=5 小於 target，故可得知 m 以及比 m 小的值 [1, 3, 5] 都不會是答案，因此保留 [7, 9] 在第二動。
    - target 為 10 => 因為 `while(l < r)`，最後 L, R 會停在 num[4]=9 上，這代表了已經沒有需要排除的解答空間，若僅剩的一個元素 9 不是答案，就沒有答案了。

## 心得
### 邊界條件
邊界條件常常會拖累撰寫速度，在此紀錄一些心得。

1. L、R

    因為 m 值計算 `m = Math.floor((l + r) / 2)`，在偶數長度情況下，m 會偏左。例如 [1, 2]，m 值為 1，此時若給予 `r = m - 1` 的條件，r 值可能會 out of bound 為 -1，因此終止時盡量選擇 L 的值來檢查可以減少很多錯誤。

2. While 等不等

    `while (l <= r)` 這個句子代表了，當 L=R (解答空間只剩下最後一個元素) 時，仍要繼續尋找答案。通常這是不必要的，當解答空間只剩一個元素時，無需 iterate 也可簡單比照答案。

3. Endless Loop 對策

    #### 原因
    容易卡住的狀況，為解答空間排除到只剩最後兩個元素時，因為兩個元素沒有中間數，Ｍ 一定會偏一邊。`floor()` 會使得 Ｍ 偏左、反之 `ceil()` 會使得 Ｍ 偏右。有類似狀況會使得 Ｍ 緊貼邊界，導致解答空間無法被排除。

    好用的驗證範例：假設陣列為 [5, 5]，Ｍ 計算偏左 (index 0)
    - 題目要求找第一個 5，因為 Ｍ 為可能的第一個 5，Ｍ 右側一定不會是第一個 5，排除右邊，收斂得到 index 0 為答案。
    - 題目要求找最後一個 5，Ｍ 為可能的最後一個 5，Ｍ 左側一定不會是最後一個 5，排除左邊，Ｍ 緊貼左邊界，導致沒有任何東西實際上被排除，下一個迴圈的 L, R, Ｍ 位置仍然不變，卡住無法收斂。

    #### 解決方案
    1. 改成 `while(l + 1 < R)`，使得 solution space 剩下最後兩個元素時直接跳出循環，自然不會卡住。缺點為需要自行判斷兩個元素哪個是答案。
    
    2. `floor()` => M 偏左 => 必須有 `l = m + 1` 條件避免卡住。
    `ceil()` => M 偏右 => 必須有 `r = m - 1` 條件避免卡住。
    
    3. 可參照 LC 34。
    
        要求第一個 (left bound) => 使用 `floor()`，使其自然偏左幫助收斂找第一。

        要求最後一個 (right bound) => 使用 `ceil()` 使其自然偏右幫助收斂找最後。
        
    4. 左閉右閉、左閉右開、左開右開，需要死背 template，不利思考順應變化。
