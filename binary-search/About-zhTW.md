## 概念
### 基礎
Binary Search 有效的秘訣是它每次都成功的排除了一半的可能性，無需遍歷所有元素，讓它能夠有 O(logn) 而不是 O(n) 的效率。
- 返回時，代表了已經在解答空間裡找到了答案
- 當它不返回而停止時，代表了已經沒有需要排除的解答空間 (solution space is empty)，所以沒必要繼續了。

### 衍伸
承基礎討論，存在兩種運用 Binary Search 的方式
1. 找到答案，最基礎的應用

    ```js
    while(l < r) {
      // ...
      if (m = target) return;
      if (m > target) // ...
      else // ...
    }

    ```

2. 利用它縮小解答空間，通常用於*不知道答案本身*，所以排除一定不是答案的一半

    ```js
    while (l < r) {
      // ...
      if (m > target) //...
      else //...
    }
    ```
    可參考 LC 744，在此要找大於 target 的最小值。

    舉例來說假設解答空間為 [1, 3, 5, 7, 9]，中間數為 num[2] = 5。以下解釋想法。

    - target 為 4 => [5, 7, 9] 都大於 target，則 [7, 9] 一定不會是最小值，而 5 是否會是答案中的最小值目前還不知道，所以保留 [1, 3, 5] 在第二動檢驗。
    - target 為 6 => m=5 小於 target，故可得知 m 以及比 m 小的值 [1, 3, 5] 都不會是答案，因此保留 [7, 9] 在第二動。
    - target 為 10 => 因為 `while(l < r)`，最後 L, R 會停在 num[4]=9 上，這代表了已經沒有需要排除的解答空間，若僅剩的一個元素 9 不是答案，就沒有答案了。

## 心得
### 邊界條件
邊界條件常常會拖累撰寫速度，在此紀錄一些心得。

1. L、R

    因為 m 值計算 `m = Math.floor((l + r) / 2)`，在奇數長度情況下，m 會偏左。例如 [1, 2]，m 值為 1，此時若給予 `r = m - 1` 的條件，r 值可能會 out of bound 為 -1，因此終止時盡量選擇 L 的值來檢查可以減少很多錯誤。

2. While 等不等

    `while (l <= r)` 這個句子代表了，當 L=R (解答空間只剩下最後一個元素) 時，仍要繼續尋找答案。通常這是不必要的，當解答空間只剩一個元素時，無需 iterate 也可簡單比照答案。
