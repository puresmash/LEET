## Pattern
利用 DFS 的特性，一條路走到底前，所用到的資源不會被其他分支使用，而可以在每次遞迴傳 reference 就好，
不用保持獨立執行環境給子任務。這點是 BFS 做不到的，但也因為這個特性，BFS 的任務比較容易平行處理拆分。

```js
// 再走其他分岔前，需要把所需資源復原 (先 push 再 pop，或先 pop 再 push)
const path = [];
// 常見的 backtracking 範例ㄧ，其實就是 LC-257
function dfs(node) {
  path.push();
  node.left && dfs(node.left);
  node.right && dfs(node.right);
  path.pop();
}
// 常見的 backtracking 範例二，同上，都是成對的操作
function dfs(i) {
  path.pop();
  dfs(i + 1);
  path.push();
}
```
如上例，可在每個節點修改共同資源來製造子問題，利用 DFS 的特性，最遲只要在返回 parent 前復原修改過的共同資源，
既可節省配置的陣列，又可保持共用資源的獨立性。

## 關於時間複雜度

遍歷所有可能的特性，其實就是一種 brute force，
甚至題目的答案本身就是所有的可能組合(combination)，而可能性的數量級會隨著 n 的大小成長很快，
所以若題目沒有給出一些限制來提供優化空間，為了避免跑太久，通常所給的問題，n 也不會太大。

話雖如此，也因為複雜性天生很大，所以也應該盡可能做短路優化，效果可能會非常有感。
(尤其是題目有時候也會特意地給一些極端例子)

### 如何計算
其中一種較通常的計算方式為樹高＊樹葉的個數 (e.g. n*2^n)，另一種方式為只計算樹葉的個數 (e.g. 2^n)。
但並不是每個題目都容易以短式表示樹高、決策樹(或可稱遞迴樹)的長相不同、剪枝的方式也不同，
故可能問 10 個人會有 10 種答案。

### 排列組合
排列不重要 -> 組合 -> 想辦法固定一種排列方式
組合 combination -> 選擇不選擇 -> 2^n
排列 permutation -> n^n
